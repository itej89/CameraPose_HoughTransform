import math
import numpy as np
import cv2 as cv

#Class contains functionality to compute
#   -hough lines
#   -Find the corners of the paper through 
#    the Point of intersection of lines generated by hough transform
class hough_compute:

    def get_hough_lines(self, color_mask, width, height):
        """method takes canny output with edges and tries to find the lines corresponding to those edges

        Args:
            color_mask (numpy array): Gray scal image out put of canny edge detector
            width (int): width of image
            height (int): height of the image

        Returns:
            tuple: detected lines, bins used for rho and angle, filtered parallel line sets
        """

        #extract the coordinates of the edge pixels
        y, x = np.nonzero(color_mask)
        
        #Define the maximum rho value to be teh legth of the diagonal of the image
        max_rho = int(np.ceil(np.sqrt(width * width + height * height)))

        #Define rho bins from negative range to positive range with 1 unit spacing
        rho_bins = np.linspace(-max_rho, max_rho, max_rho * 2)
        #Define angle bins from 0 to 180 with bin size of 1 degree
        angle_bins = np.deg2rad(np.arange(0.0, 180.0))

        #Create pixel-to-line vote matrix
        vote_matrix = np.zeros((2 * max_rho, len(angle_bins)), dtype=np.uint8)
        
        #Compute rhos corresponding to the votes made by the edge pixels
        cosines = np.cos(angle_bins).reshape(1, len(angle_bins), 1)
        sines   = np.sin(angle_bins).reshape(1, len(angle_bins), 1)
        votes_rhos = np.round(x*cosines + y*sines)  + max_rho
        votes_rhos = np.array(votes_rhos[0])

        #create theta arrays corresping to the rhos selected by the pixels
        vote_thetas = np.array([*range(len(votes_rhos[:, 0]))])
        vote_thetas  = np.array(vote_thetas).reshape(1,len(vote_thetas))
        vote_thetas = np.repeat(vote_thetas, len(votes_rhos[0]), axis = 0).T

        #variable to store hough lines
        lines = []
        #variable to store fitlered parallel sets from the hough lines
        parallel_set1 = []
        parallel_set2 = []

        #Create a list of rhos for each theta selected by every pixel
        # This list contains repititions of same rhos and thetas selected by multiple pixels
        vote_idx = np.array(list(zip(votes_rhos.ravel(),vote_thetas.ravel())), dtype=('i4,i4')).reshape(vote_thetas.shape).ravel()

        #Extract unique vote ie,(rhos, theta) and the numbe of votes for each rho
        rhos, counts = np.unique(vote_idx, return_counts=True)

        rhos, thetas = list(zip(*rhos))
        #update the vote matrix with the total votes recieved for each cell
        vote_matrix[rhos,thetas] = counts

        #Extract required 4 lines from the top 10 lines detected
        max_lines = 10
        #extract count of max 10 votes from the vote matrix
        votes = np.partition(np.sort(vote_matrix.flatten()), -1*max_lines)

        for i in range(1, max_lines+1):
            #get indices of ie., rho theta of each max vote
            idx = np.where(vote_matrix == votes[-i])

            #detect and discord duplicated lines by comparing with already collected lines
            # Criterial : rho < 100 and theta < 5 degrees
            duplicate_line = False
            for line in lines:
                if abs(line[0][0] - idx[0][0]) < 100 and abs(line[1][0] - idx[1][0]) < 5:
                    duplicate_line = True
            
            #Append new line and added it to the two parallel sets of lines corresponding to the rectangle
            if not duplicate_line:
                lines.append(idx)

                # if first line, just add it to the list
                if len(parallel_set1) == 0 and len(parallel_set2) == 0:
                    parallel_set1.append(idx)
                
                #check if the line belongs to set 1 or set 2
                #   Criteria : angle between lines greater than 50

                elif len(parallel_set1) > 0:
                    if abs(parallel_set1[0][1][0] - idx[1][0]) > 50:
                        parallel_set2.append(idx)
                    else:
                        parallel_set1.append(idx)

                elif len(parallel_set2) > 0:
                    if abs(parallel_set2[0][1][0] - idx[1][0]) > 50:
                        parallel_set1.append(idx)
                    else:
                        parallel_set2.append(idx)

        #return the computed lines and meta information
        return lines, rho_bins, angle_bins, parallel_set1, parallel_set2
    

    def find_intersection(self, line1, line2 ,rho_bins, angle_bins):
        """Funciton to find intersection between two lines

        Args:
            line1 (tuple): rho and theta correcspondint ot line1
            line2 (tuple): rho and theta correcspondint ot line2
            rho_bins (list): list of rhos
            angle_bins (list): list of thetas

        Returns:
            list: intersenction of two lines
        """
        rho1 = rho_bins[line1[0][0]]
        theta1 = angle_bins[line1[1][0]]

        rho2 = rho_bins[line2[0][0]]
        theta2 = angle_bins[line2[1][0]]

        #Find the intersenction in slope intercept space
        m = np.array([ [np.cos(theta1), np.sin(theta1)], [np.cos(theta2), np.sin(theta2)]])
        b = np.array([[rho1], [rho2]])

        #solve the equations ot find the intercept
        x, y = np.linalg.solve(m, b)

        return np.round([x.ravel()[0],y.ravel()[0]]).astype(np.int)

    def find_corners(self, parallel_set1, parallel_set2, rho_bins, angle_bins):
        """Find corners of the paper from the given two sets of parallel lines

        Args:
            parallel_set1 (list): list of rhos and thetas corresponding to one set of parallel lines
            parallel_set2 (list): list of rhos and thetas corresponding to second set of parallel lines
            rho_bins (list): list of rhos
            angle_bins (list): list of thetas

        Returns:
            list: intersenction of two lines
        """

        corners = []
        #loop through each pairs of perpendicular lines and find the intercept
        if len(parallel_set1) > 0 and len(parallel_set2) > 0:
            for l1 in parallel_set1:
                for l2 in parallel_set2:
                    corner = self.find_intersection(l1, l2, rho_bins, angle_bins)
                    corners.append([corner[0], corner[1]])

        corners = np.array(corners)

        #sort corners from left to right on the image
        corners =  corners[corners[:, 0].argsort()]
        
        #return corners
        return corners